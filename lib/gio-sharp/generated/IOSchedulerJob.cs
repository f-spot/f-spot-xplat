// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace GLib {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class IOSchedulerJob : GLib.Opaque {

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_io_scheduler_job_send_to_mainloop(IntPtr raw, GLibSharp.GSourceFuncNative func, IntPtr user_data, GLib.DestroyNotify notify);

		public bool SendToMainloop(GLib.GSourceFunc func) {
			var func_wrapper = new GLibSharp.GSourceFuncWrapper (func);
			IntPtr user_data;
			GLib.DestroyNotify notify;
			if (func == null) {
				user_data = IntPtr.Zero;
				notify = null;
			} else {
				user_data = (IntPtr) GCHandle.Alloc (func_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			bool raw_ret = g_io_scheduler_job_send_to_mainloop(Handle, func_wrapper.NativeDelegate, user_data, notify);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_io_scheduler_job_send_to_mainloop_async(IntPtr raw, GLibSharp.GSourceFuncNative func, IntPtr user_data, GLib.DestroyNotify notify);

		public void SendToMainloopAsync(GLib.GSourceFunc func) {
			var func_wrapper = new GLibSharp.GSourceFuncWrapper (func);
			IntPtr user_data;
			GLib.DestroyNotify notify;
			if (func == null) {
				user_data = IntPtr.Zero;
				notify = null;
			} else {
				user_data = (IntPtr) GCHandle.Alloc (func_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			g_io_scheduler_job_send_to_mainloop_async(Handle, func_wrapper.NativeDelegate, user_data, notify);
		}

		public IOSchedulerJob(IntPtr raw) : base(raw) {}

#endregion
	}
}
